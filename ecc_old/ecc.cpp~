// ecc.cpp : コンソール アプリケーションのエントリ ポイントを定義します。
// jdbl,jaddは射影座標です。x=X/Z;y=Y/Z;でaffine座標に変換できます。
// 2016.2.18 ecdsa を追加しました。


#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include "hash2.c"
#include "seed2.cpp"
#include "bigint.h"
#include "sha256.cpp"



#define _SHA256_WITH_MAIN

#ifdef _SHA256_WITH_MAIN
#include <cstdio>
#include <cstring>
#endif


#define _HAS_ITERATOR_DEBUGGING 0

#include <string.h>
#ifdef WIN32
#include <io.h>
#endif

#define bit(KK,i) ((KK ^ (1<<i))>>i)%2==0)



//def M32(x) (((1 << 32)-1)&(x)) end


BigInt KEYDEF;
BigInt KEYDEF2;
BigInt GROUP_GENERATOR;
BigInt K;



//from RFC2409
//dsa.rb Ruby version
//@GROUP_GENERATOR=2

// Default modulus value by zebedee
BigInt DFLT_MODULUS;



/*
=begin
//...If you want to abandon man-in-the-middle-attack you must exchange
//a Public key with it's own signature on DH key exchange.
//Here is a signature method NR & DSA with blind.
=end
*/

// GCD
BigInt gcd(BigInt xx,BigInt yy){
  BigInt tt;

  while (yy != 0){
    tt = xx % yy;
    xx = yy;
    yy = tt;
    }

  return xx;
  
}


// invert of integer
BigInt inv(BigInt a,BigInt n){
  BigInt d,x,s,q,r,t;


  d = n;
  x = 0;
  s = 1;
while (a != 0){
    q = d / a;
    r = d % a;
    d = a;
    a = r;
    t = x - q * s;
    x = s;
    s = t;
}
//  gcd = d;  // $\gcd(a, n)$ 

  return ((x + n) % (n / d));
}

/*
//jj=aa^bb mod oo
BigInt exp(BigInt aa,BigInt bb,BigInt oo){
  BigInt ii,jj,kk[8192];
  int j,c[8192],count=0,i;

 ii=oo;
  j=0;
  jj=0;
//  kk[4096]; //prime is 4096 bit table
//  c[8192]  //mod is 8192 bit table
  count=0;

  for(i=0;i<8192;i++){
    kk[i]=0;
    }
  while(ii>0){
    ii = (ii>>1);
    j=j+1;
  }


  kk[0]=aa;

//  std::cout << j << "\n";
  
//ex.1000=2**3+2**5+2**6+2**7+2**8+2**9 makes a array c=[3,5,6,7,8,9]
  for(i=0;i<j+1;i++){
      if(bit(bb,i) != 0){ // testbit(bb,i)
	c[count]=i;
	count=count+1;
      }
    }
//    std::cout << bb << endl;
//    std::cout << count << "\n";
//exit(1);
    for(i=1;i<c[count-1]+1;i++){
      kk[i] = kk[i-1]*kk[i-1]%oo;
    }

    jj=1;
    for(i=0;i<count;i++){
      jj=kk[c[i]]*jj%oo;
      if (jj==0){
//	print i,"\n"
      }
    }

    return jj;
}
*/

// p>q=(p-1)/2 
void dsa(BigInt m,BigInt s56){
BigInt rr,a_r,a_s,Pub_key;

 std::cin >>K ;
  //k is select atrandom
  if((KEYDEF-1)%K==0){
    std::cout << "bad k\n";
    exit(1);
    }
  rr=BigInt(GROUP_GENERATOR).pow(K)%KEYDEF;
  a_r = rr % KEYDEF2;
  std::cout << a_r << "\n";
  a_s=(K*m+s56*a_r)%KEYDEF2;
  std::cout << a_s << "\n";

}


// verify DSA signature
void vera(void){
BigInt tt,v,q,m,a_r,a_s,Pub_key;
  
  std::cin >> Pub_key;
  std::cin >> m;
  std::cin >> a_r;
  std::cin >> a_s;
  //  m=sha(argc,argv);
  tt=BigInt(GROUP_GENERATOR).pow(a_s)%KEYDEF; // g^{(km+xr)%mod}=g^km*g^xr
  q=BigInt(Pub_key).pow(a_r)%KEYDEF; // g^{r*x}
  q=inv(q,KEYDEF); // g^{-xr}
  tt=tt*q%KEYDEF; // g^{(km+xr)%mod-xr}
  m=inv(m,KEYDEF2);
  tt=BigInt(tt).pow(m)%KEYDEF; // g^k
  v=tt%KEYDEF2;

if(a_r!=v){
   std::cout << "baka\n";
}
if(a_r==v){
    std::cout << "That's True!\n";
}
}

void mp_init(int n){

  if(n==1024){
  KEYDEF="101459693097608319042758415833807677670847628544715540724500026735349301068515392099767184641851031376113522183648115338953972239406909609350543459251533166139494901562515248706419170211273185584865994044063658192209029166200554581462882695234974056443041028708526103161707004900985186431045546342831775691541";
  KEYDEF2="776378143341645114049424495943980057469202238087";
  //std::cout << n << endl;
  }
// 2048-bitMODPGroup
  if (n==2048){
  //DSA2-2048
  KEYDEF="30981723345974435010161909523496552974699533919934322379085614661498636798097568515214479822262348814635668373190596212356380711940945934922154014218679943787759116924209774502274268759042349702152136214836347166635609098903049845488225777238895118712670994018901432361245969980840078167888393860223326555502924507123955659138424915625337173774451718035807621447511725643561397746198018458567222530032058288731896581568162423781624070371332903949092124341245711835360848611974141912660194445611902431634123654857731781595663275337139561826932358567214803181529834262455954351466450805559661991067483130544841970662773";
  KEYDEF2="87887965594022234641736188661435007486940516303779074733210399408420032394343";
  }

// 3072-bitMODPGroup
  if (n==3072){
  //DSA2-3072
  KEYDEF="3268470001596555685058361448517594259852327289373621024658735136696086397532371469771539343923030165357102680953673099920140531685895962914337283929936606946054169620100988870978124749211273448893822273457310556591818639255714375162549119727203843057453108725240320611822327564102565670538516259921126103868685909602654213513456013263604608261355992328266121535954955860230896921190144484094504405550995009524584190435021785232142953886543340776477964177437292693777245368918022174701350793004000567940200059239843923046609830997768443610635397652600287237380936753914127667182396037677536643969081476599565572030244212618673244188481261912792928641006121759661066004079860474019965998840960514950091456436975501582488835454404626979061889799215263467208398224888341946121760934377719355124007835365528307011851448463147156027381826788422151698720245080057213877012399103133913857496236799905578345362183817511242131464964979";
  KEYDEF2="93911948940456861795388745207400704369329482570245279608597521715921884786973";
  }

//4096-bit
  if(n==4096){
    KEYDEF="1044388881413152506679602719846529545831269060992135009022588756444338172022322690710444046669809783930111585737890362691860127079270495454517218673016928427459146001866885779762982229321192368303346235204368051010309155674155697460347176946394076535157284994895284821633700921811716738972451834979455897010306333468590751358365138782250372269117968985194322444535687415522007151638638141456178420621277822674995027990278673458629544391736919766299005511505446177668154446234882665961680796576903199116089347634947187778906528008004756692571666922964122566174582776707332452371001272163776841229318324903125740713574141005124561965913888899753461735347970011693256316751660678950830027510255804846105583465055446615090444309583050775808509297040039680057435342253926566240898195863631588888936364129920059308455669454034010391478238784189888594672336242763795138176353222845524644040094258962433613354036104643881925238489224010194193088911666165584229424668165441688927790460608264864204237717002054744337988941974661214699689706521543006262604535890998125752275942608772174376107314217749233048217904944409836238235772306749874396760463376480215133461333478395682746608242585133953883882226786118030184028136755970045385534758453247";
    //0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D788719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA993B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934063199FFFFFFFFFFFFFFFF";
  }
  if(n==6144){
//6192-bit
    KEYDEF="33751521821438561184518523159967412330064897805741846548173890474429429901326672445203235101919165483964194359460994881062089387893762814044257438204432573941083014827006090258925875161018096327732335800595831915976014208822304007327848132734933297885803213675261564962603340457220776826322500058091310967253976619973988033663666385188155212656268079501726223369693427999804134467810120772356498596945532366527400517575471969335854905274504119509592366013711954148258884879224599915203456315881034776553083676995718335598586395591169999570824515035017543533352697525287753332500527176569576894926734950469293596134095086603716860086302051544539652689091299099784588919052383463057789440565460681441902442399956419060521629604697347879024654313800186078316526964529288062740879011035175920059192178561473199006205896719435014765345518490882366607110905303449152556221163232127426440691921134648766635695850239231304591744215610985029636895406718880766308249227315984267542266259489684372223916445411015900506239419267909716320331208988978180868987431623710347617992356201449023892203230133009421463914291201346063125219636964261683591541014344239275340735690997732222069758773963390876360546515755280517042160525487302898122311669799679447530453600399342697032714458549591285939453949034981248114322322367238645042515984447890788917823576330019151696568654314153058547592091366014550143819685170068343700104677609041166369760080933413605498962382077778845599834907475953430787446201384567328530675275792962354883770806900827183685718353469574731680520621944540947734619035177180057973022652571032196598229259194875709994709721793154158686515748507274224181316948797104601068212015232921691482496346854413698719750190601102705274481050543239815130686073601076304512284549218459846046082253596762433827419060089029417044871218316020923109988915707117567";
    //0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D788719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA993B4EA988D8FDDC186FFB7DC90A6C08F4DF435C93402849236C3FAB4D27C7026C1D4DCB2602646DEC9751E763DBA37BDF8FF9406AD9E530EE5DB382F413001AEB06A53ED9027D831179727B0865A8918DA3EDBEBCF9B14ED44CE6CBACED4BB1BDB7F1447E6CC254B332051512BD7AF426FB8F401378CD2BF5983CA01C64B92ECF032EA15D1721D03F482D7CE6E74FEF6D55E702F46980C82B5A84031900B1C9E59E7C97FBEC7E8F323A97A7E36CC88BE0F1D45B7FF585AC54BD407B22B4154AACC8F6D7EBF48E1D814CC5ED20F8037E0A79715EEF29BE32806A1D58BB7C5DA76F550AA3D8A1FBFF0EB19CCB1A313D55CDA56C9EC2EF29632387FE8D76E3C0468043E8F663F4860EE12BF2D5B0B7474D6E694F91E6DCC4024FFFFFFFFFFFFFFFF";
  }
  if(n==8192){

//7.8192ビットMODPグループInEnglish
//このグループには、ID18が割り当てられている。
//素数（prime）:2^8192-2^8128-1+2^64*{[2^8062pi]+4743158}

    KEYDEF="1090748135619415929450294929359784500348155124953172211774101106966150168922785639028532473848836817769712164169076432969224698752674677662739994265785437233596157045970922338040698100507861033047312331823982435279475700199860971612732540528796554502867919746776983759391475987142521315878719577519148811830879919426939958487087540965716419167467499326156226529675209172277001377591248147563782880558861083327174154014975134893125116015776318890295960698011614157721282527539468816519319333337503114777192360412281721018955834377615480468479252748867320362385355596601795122806756217713579819870634321561907813255153703950795271232652404894983869492174481652303803498881366210508647263668376514131031102336837488999775744046733651827239395353540348414872854639719294694323450186884189822544540647226987292160693184734654941906936646576130260972193280317171696418971553954161446191759093719524951116705577362073481319296041201283516154269044389257727700289684119460283480452306204130024913879981135908026983868205969318167819680850998649694416907952712904962404937775789698917207356355227455066183815847669135530549755439819480321732925869069136146085326382334628745456398071603058051634209386708703306545903199608523824513729625136659128221100967735450519952404248198262813831097374261650380017277916975324134846574681307337017380830353680623216336949471306191686438249305686413380231046096450953594089375540285037292470929395114028305547452584962074309438151825437902976012891749355198678420603722034900311364893046495761404333938686140037848030916292543273684533640032637639100774502371542479302473698388692892420946478947733800387782741417786484770190108867879778991633218628640533982619322466154883011452291890252336487236086654396093853898628805813177559162076363154436494477507871294119841637867701722166609831201845484078070518041336869808398454625586921201308185638888082699408686536045192649569198110353659943111802300636106509865023943661829436426563007917282050894429388841748885398290707743052973605359277515749619730823773215894755121761467887865327707115573804264519206349215850195195364813387526811742474131549802130246506341207020335797706780705406945275438806265978516209706795702579244075380490231741030862614968783306207869687868108423639971983209077624758080499988275591392787267627182442892809646874228263172435642368588260139161962836121481966092745325488641054238839295138992979335446110090325230955276870524611359124918392740353154294858383359";
    //0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D788719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA993B4EA988D8FDDC186FFB7DC90A6C08F4DF435C93402849236C3FAB4D27C7026C1D4DCB2602646DEC9751E763DBA37BDF8FF9406AD9E530EE5DB382F413001AEB06A53ED9027D831179727B0865A8918DA3EDBEBCF9B14ED44CE6CBACED4BB1BDB7F1447E6CC254B332051512BD7AF426FB8F401378CD2BF5983CA01C64B92ECF032EA15D1721D03F482D7CE6E74FEF6D55E702F46980C82B5A84031900B1C9E59E7C97FBEC7E8F323A97A7E36CC88BE0F1D45B7FF585AC54BD407B22B4154AACC8F6D7EBF48E1D814CC5ED20F8037E0A79715EEF29BE32806A1D58BB7C5DA76F550AA3D8A1FBFF0EB19CCB1A313D55CDA56C9EC2EF29632387FE8D76E3C0468043E8F663F4860EE12BF2D5B0B7474D6E694F91E6DBE115974A3926F12FEE5E438777CB6A932DF8CD8BEC4D073B931BA3BC832B68D9DD300741FA7BF8AFC47ED2576F6936BA424663AAB639C5AE4F5683423B4742BF1C978238F16CBE39D652DE3FDB8BEFC848AD922222E04A4037C0713EB57A81A23F0C73473FC646CEA306B4BCBC8862F8385DDFA9D4B7FA2C087E879683303ED5BDD3A062B3CF5B3A278A66D2A13F83F44F82DDF310EE074AB6A364597E899A0255DC164F31CC50846851DF9AB48195DED7EA1B1D510BD7EE74D73FAF36BC31ECFA268359046F4EB879F924009438B481C6CD7889A002ED5EE382BC9190DA6FC026E479558E4475677E9AA9E3050E2765694DFC81F56E880B96E7160C980DD98EDD3DFFFFFFFFFFFFFFFFF";
  }
  
}


int dsa2(int argc,char *argv[]){

  int n,i,j,read_size;
  FILE *fp;
  char m[32],s[32];
  BigInt xx,s56,s128,s64,s168,gay,yy,md,Pub_key;
  BigInt ee;
  


fp=fopen("key.bin","rb";
  
  
 std::cout << "decide MODP size n" << endl;
 // std::cin >> n;
   n=3072;

  mp_init(n);
  //  std::cout << "n=" << n << "\n";

    if (n!= 1024 && n!=2048 && n!=3072){
   std::cout << "You can select from next parametors 1024,2048\n";
   std::cout << "3072. First [./dsa file] Next you need to input\n";
   std::cout << "one of these dsa key size.\n";
   std::cout << "Note this version's signature is not secure because of \n";
   }



//default:print"Chooseyourkeysize","\n"




//chooserandomsecretkeys(largerthans128-bit)
s128="340282055605427970793192457633571187455";
s168="373779281620604392915322569464050882390986703503105";
fread(m,1,32,fp);
read_size=fread(s,1,32,fp);
//std::cout<<read_size<<endl;

gay=0;
for(i=0;i<32;i++)
gay=(gay<<8)^s[i];
//3618502788666131106986593281527206111185510860325500770110842981586944655359";


//std::cout<<"kissecretnumberwhichissenderchoosedatrandom"<<endl;

//=22387645283764583276458327645823764528376458327645832764528376452837645238764528376453287645";
//freopen("con","r",stdin);

GROUP_GENERATOR=exp(gay,(KEYDEF-1)/KEYDEF2,KEYDEF);
if((KEYDEF-1)%KEYDEF2!=0)
exit(1);

yy=exp(GROUP_GENERATOR,gay,KEYDEF);//PublicKey
std::cout<<yy<<endl;
Pub_key=yy;
if(n==1024){
ee=sha2(argc,argv);
}else//if(strcmp(argv[1],"3")
md=sha2(argc,argv);
std::cout<<md<<endl;
//printf("%08X%08X%08X%08X%08X\n",ee.MD[0],ee.MD[1],ee.MD[2],ee.MD[3],ee.MD[4]);
//e=("0x"+STATUS).hex
/*
if(n==1024){
md=to_BigInt(ee.MD[0]);
md=(md<<32)^to_BigInt(ee.MD[1]);
md=(md<<32)^to_BigInt(ee.MD[2]);
md=(md<<32)^to_BigInt(ee.MD[3]);
md=(md<<32)^to_BigInt(ee.MD[4]);
}
*/
//std::cout<<argv[1]<<"'sDSASignatureis\n";
if(!strcmp(argv[1],"1")
dsa(md,gay);
if(!strcmp(argv[1],"2")
vera();

return 0;
}






int A=0;
int B=0;

typedef struct{
BigInt x;
BigInt y;
} po;
typedef struct{
BigInt x;
BigInt y;
BigInt z;
} ten;
typedef struct{
char *name;
BigInt p;
BigInt seedE;
BigInt r;
BigInt a;
BigInt b;
ten G;
BigInt n;
int h;
BigInt inv;
} cv;
typedef struct{
unsigned int MD[8];
} arr;


cv CRV;
po le[256];
ten ll[256];
ten Pub_key;
po T;//eadd
po D;//edbl
ten P;//ead2
ten Q;//edl2
po N[256];//le_temp
ten M[256];//ll_temp
ten Gen_key;//randompoint
BigInt a3[100000];
int a2[100000],a4[100000];
//,pp=0;
//chargg[32];


//poPub_key;
//unsignedlonglongintg3[256][2],g4[256][2];
//intE_K=0;
BigInt I[9000];



void init_curve(int n){

if(n==224){
//"{CBD61FC1-F50D-4","P-224","p=2^224-2^96+1",
CRV.name="eccp224";
CRV.p="26959946667150639794667015087019630673557916260026308143510066298881";
CRV.seedE="0xbd71344799d5c7fcdc45b59fa3b9ab8f6a948bc5";
CRV.r="0x5b056c7e11dd68f40469ee7f3c7a7d74f7d121116506d031218291fb";
CRV.a="-3";
CRV.b="0xb4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4";
CRV.G.x="0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21";
CRV.G.y="0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34";
CRV.G.z="1";
CRV.n="26959946667150639794667015087019625940457807714424391721682722368061";
CRV.h="1";
CRV.inv="13479973333575319897333507543509815336778958130013154071755033149441";
}

if(n==2244){
CRV.n="13479973333575319897333507543509819484712548793029295142314934474707";
//doyouwanttoproceedwiththisone(Y/N)?y
CRV.a="-3";
CRV.b="7926735752311977820224618556926799352231714653617375950103029803860";
CRV.p="26959946667150639794667015087019630673557916260026308143510066298881";
//R=13479973333575319897333507543509819484712548793029295142314934474707a224bitprime
CRV.G.x="24155712282000049631001357595395450813097367499938434330297713128801";
CRV.G.y="5882461958218329457915762297197751647381159972043925920846779622521";
CRV.G.z="1";
CRV.inv="13479973333575319897333507543509815336778958130013154071755033149441";
}

if(n==256){
//"{B858801C-582E-4","P-256","p=2^256-2^224+2^N+2^96-1",
CRV.name="eccp256";
CRV.p="115792089210356248762697446949407573530086143415290314195533631308867097853951";
CRV.seedE="1122468115042657169822351801880191947498376363664";
CRV.r="57436011470200155964173534038266061871440426244159038175955947309464595790349";
CRV.a="-3";
CRV.b="41058363725152142129326129780047268409114441015993725554835256314039467401291";
CRV.G.x="48439561293906451759052585252797914202762949526041747995844080717082404635286";
CRV.G.y="36134250956749795798585127919587881956611106672985015071877198253568414405109";
CRV.G.z="1";
CRV.n="115792089210356248762697446949407573529996955224135760342422259061068512044369";
CRV.h="1";
CRV.inv="57896044605178124381348723474703786765043071707645157097766815654433548926976";
}

if(n==2563){
CRV.name="eccp256r2";
CRV.p="115792089210356248762697446949407573530086143415290314195533631308867097853951";
CRV.a="115792089210356248762697446949407573530086143415290314195533631308867097853948";
CRV.b="41058363725152142129326129780047268409114441015993725554835256314039467401291";
CRV.G.x="395815829005855038029765540278861637762572903522963440114216832740821793555094";
CRV.G.y="30769603638631994634479180612906047718205418376298768584198191172839256571736";
CRV.G.z="1";
CRV.n="115792089210356248762697446949407573529996955224135760342422259061068512044369";
}

if(n==2562){

CRV.a="20549773689227812627292831297245718700081937423295476612608601227386727850553";
CRV.b="47623312769896854212861199545761181316171213330096761101722264837667685936281";
CRV.n="101770390931234937383997936042792106547711735705722570460955764669295036711143";
CRV.p="101770390931234937383997936042792106548349765143699330079949592058229602107737";
CRV.G.y="16845429027015099874700368857878626645060314647744100515127489968869022719070";
//84924961904219837509297567184913479903289450495955229564822102089360579388667";
CRV.G.x="38996611774847114330982137792567050762097251424678060141486085082902623877233";
//
//w=59
CRV.G.z="1";

/*
CRV.name="eccp256r1";
CRV.p=115792089210356248762697446949407573530086143415290314195533631308867097853951";
CRV.a=115792089210356248762697446949407573530086143415290314195533631308867097853948";
CRV.b=41058363725152142129326129780047268409114441015993725554835256314039467401291";
CRV.seedE=1122468115042657169822351801880191947498376363664";
CRV.G.x=395815829005855038029765540278861637762572903522963440114216832740821793555094";
CRV.G.y=3600254559212783631020592788373957154744735408555473783510957625074434451321";
//59240149723730851812311272008153533141816437726696305166080887910572446982458012615605924465554721774228350039774385670824392793454808075284049927019123189";
CRV.G.z=1;
CRV.n=115792089210356248762697446949407573529996955224135760342422259061068512044369";
CRV.h=1;
CRV.inv=57896044605178124381348723474703786765043071707645157097766815654433548926976";
*/
}

if(n==2564){
CRV.a="325379667707489826401064228424852592079356807922648328779606654148301710111";
CRV.b="43638953242465233168106495530541200510616011708075374527275181032002171872628";
CRV.n="65133050195990359925758679067386948173334237203809005766938102982707303781623";
CRV.p="65133050195990359925758679067386948173844660754190413462133164893854956098831";
//infinity devide1
CRV.G.x="18487703388218368811611273467885185415041771995400161457848598846868890320470";
CRV.G.y="24687222602040641145870602721247005746364795831134621092877670314906490902760";
CRV.G.z="1";
}

if(n==2565){
CRV.a="50615278656685320126791612967404283968036974455733654200179080720363497751491";
CRV.b="33743519104456880084527741978269522645357982970489102800119387146908998500994";
CRV.n="65133050195990359925758679067386948208553462180126136735397374851843822399097";
CRV.p="65133050195990359925758679067386948209063885730507544430592436762991474716443";
//infinity devide1
CRV.G.x="63582577761502127973450815015383738377077716646935254059256424901755563321273";
CRV.G.y="22895574053820059180945744963571496712404540419433716833791593749823092772659";
CRV.G.z="1";
}

if(n==2566){

CRV.a="58619423044276027832903787065716086236095439918520509851335164825122761913928";
CRV.b="5156151719105706093936546029546688635963459581307566382625017622890757039103";
CRV.n="101770390931234937383997936042792106563662471655141560935801449392638687313903";
CRV.p="101770390931234937383997936042792106564300501093118320554795276781573252710547";
CRV.G.y="98399506821057818865862588903161792587668472549669649472059793708337005935795";
CRV.G.x="28663290192706932057771677870920156363737430016916930158558409220429370107804";
CRV.G.z="1";
}

if(n==384){
//Grouporder=
CRV.n="5628858028056354173182720014306230543582819895780778095420563755345515056616034903125147135939193286284507539411263";
CRV.a="-3";
CRV.b="7480836070348502192310144960168319822230417316926886013721948420378391982808980728605112950230878688086816085055381";
CRV.p="39402006196394479212279040100143613805079739270465446667948293404245721771497210611414187026722401376469034446356971";
//R=5628858028056354173182720014306230543582819895780778095420563755345515056616034903125147135939193286284507539411263a382bitprime
CRV.G.x="13839325240143548436618097820237988853510646421495011597727751118065256776775190573162986203269450299582183630276103";
CRV.G.y="33479584122550753431257252642915332781925124384694439200422942083526531640009189112108669026825242814943349686581134";
CRV.G.z="1";
}

}




BigInt isqrt(BigInt x){
BigInt t,s;

/*
if(x==0)
return0;
*/
s=1;
t=x;
while(s<t){
s<<=1;
t>>=1;
}
while(s<t){
t=s;
s=(x/s+s)>>1;
}

return t;

}


void jadd(ten G1,ten G2){
BigInt u1,u2,s1,s2,h,r,rev,reb,re6;
BigInt x1,x2,y1,y2,z1,z2,mod;

x1=G1.x;x2=G2.x;y1=G1.y;y2=G2.y;z1=G1.z;z2=G2.z;
mod=CRV.p;

if(x1==x2&&y1==y2&&z1==z2){
std::cout<<"infinitydevide1\n";
std::cout<<"Y1="<<y1<<"\n";
std::cout<<"Y2="<<y2<<"\n";
exit(1);
}

u1=x1*z2*z2;
u2=x2*z1*z1;
s1=y1*z2*z2*z2;
s2=y2*z1*z1*z1;
h=u2-u1;
r=s2-s1;
P.x=(-h*-h*-h-2*u1*h*h+r*r)%mod;
P.y=(-s1*h*h*h+r*(u1*h*h-P.x))%mod;
P.z=(z1*z2*h)%mod;

//=begin
rev=inv(P.z,mod);
reb=inv(P.z*P.z,mod);
re6=inv(P.z*P.z*P.z,mod);
P.x=reb*P.x%mod;
P.y=re6*P.y%mod;
P.z=rev*P.z%mod;

if(P.y*P.y%CRV.p!=(P.x*P.x*P.x+CRV.a*P.x*P.z*P.z*P.z*P.z+CRV.b*P.z*P.z*P.z*P.z*P.z*P.z)%CRV.p){
std::cout<<"errjadd\n";
exit(1);
}

}


void jdbl(ten T){
BigInt s,m,t,x,y,z;

x=T.x;
y=T.y;
z=T.z;

s=4*x*y*y;
m=3*x*x+CRV.a*(z*z*z*z);
t=-2*s+m*m;
Q.x=t%CRV.p;
Q.y=(-8*(y*y*y*y)+m*(s-t))%CRV.p;
Q.z=2*y*z%CRV.p;


if(Q.y*Q.y%CRV.p!=(Q.x*Q.x*Q.x+CRV.a*Q.x*Q.z*Q.z*Q.z*Q.z+CRV.b*Q.z*Q.z*Q.z*Q.z*Q.z*Q.z)%CRV.p){
std::cout<<"errjdbl\n";
exit(1);
}

}


//make a calcrationtablefrombasepointQ
void mktbl3(ten T){
BigInt pp,xx,yy,zz,a;
int i;
ten O;

//std::cout<<"in_mktbl3\n";


//printCRV_name,"\n"
pp=CRV.p;
//printpp,"\n"
xx=T.x;
//printxx,"\n"
yy=T.y;
//print"y=",yy,"\n"
zz=T.z;
//print"z!=",zz,"\n"
a=CRV.a;
//printa,"\n"
//printCRV_b,"\n"


//enzantable
ll[0].x=xx;
ll[0].y=yy;
ll[0].z=zz;
O.x=xx;
O.y=yy;
O.z=zz;
for(i=1;i<256;i++){//beginPub_keyatplain
if(yy==0){
std::cout<<"Yga"<<i<<"\n";
//exit()
}

jdbl(O);
ll[i].x=Q.x;
ll[i].y=Q.y;
ll[i].z=Q.z;

O.x=ll[i].x;
O.y=ll[i].y;
O.z=ll[i].z;
}
//offor
//std::cout<<"endofmktbl3\n";

}


ten elp(BigInt k,ten Z){
ten E,F;
int flg=0,l=0,i;

if(k==0)
return CRV.G;

E=Z;

while(k%2==0){
jdbl(E);
E=Q;
k=(k>>1);
}

F=E;
while(k>0){
k=(k>>1);
jdbl(F);
F=Q;
if(k%2==1){
jadd(E,F);
E=P;
}
}

return E;
}


//ComputeQ=mG
void elp3(BigInt k){
int ki[256];
BigInt L;
po s;
int j,l,i,ii,jj;


j=0;
l=0;
if(k<0){
std::cout<<"obsenseK\n";
std::cout<<k<<"\n";
exit(1);
}

if(k==0){
std::cout<<"infinitydevide2\n";
s.x=0;
s.y=0;
}

if(k>CRV.n){
k=k%CRV.n;
}

for(j=0;j<256;j++){
ki[j]=0;
}

L=k;
while(L>0){
L=(L>>1);
l=l+1;
}

L=k;
if(j!=0){
j=0;
}
//std::cout<<L<<endl;
//if(((KK^(1<<i))>>i)%2==0)//testbit(KK,i)<-shippai
for(i=0;i<l;i++){
if(L%2==1){
ki[j]=i;

j=j+1;
}
L=(L>>1);
}
//std::cout<<j<<endl;
//exit(1);
Pub_key.x=ll[ki[0]].x;
Pub_key.y=ll[ki[0]].y;
Pub_key.z=ll[ki[0]].z;
//std::cout<<Pub_key.x<<endl;
//print"j=",j,"\n"

if(k>0){
for(i=1;i<j;i++){
if(Pub_key.x!=ll[ki[i]].x||Pub_key.y!=ll[ki[i]].y||Pub_key.z!=ll[ki[i]].z){

if(Pub_key.y*Pub_key.y%CRV.p==(Pub_key.x*Pub_key.x*Pub_key.x+CRV.a*Pub_key.x*(Pub_key.z*Pub_key.z*Pub_key.z*Pub_key.z)+CRV.b*(Pub_key.z*Pub_key.z*Pub_key.z*Pub_key.z*Pub_key.z*Pub_key.z))%CRV.p){
//std::cout<<"doko2\n";
if(ll[ki[i]].y*ll[ki[i]].y%CRV.p==(ll[ki[i]].x*ll[ki[i]].x*ll[ki[i]].x+CRV.a*ll[ki[i]].x*(ll[ki[i]].z*ll[ki[i]].z*ll[ki[i]].z*ll[ki[i]].z)+CRV.b*(ll[ki[i]].z*ll[ki[i]].z*ll[ki[i]].z*ll[ki[i]].z*ll[ki[i]].z*ll[ki[i]].z))%CRV.p){
//std::cout<<"doko3\n";
jadd(Pub_key,ll[ki[i]]);
Pub_key.x=P.x;
Pub_key.y=P.y;
Pub_key.z=P.z;
if(Pub_key.x==0&&Pub_key.y==0&&Pub_key.z==0){
//	if(Pub_key_z==0)
std::cout<<Pub_key.x<<","<<Pub_key.y<<","<<Pub_key.z<<"\n";
std::cout<<"infinitydevide3\n";
exit(1);
}
//print"doko4\n"
}

//print"end1\n"
}
//print"end2\n"
}
//print"end3\n"
if(Pub_key.x==ll[ki[i]].x&&Pub_key.y==ll[ki[i]].y&&Pub_key.z==ll[ki[i]].z){

//print"ecole\n"
jdbl(Pub_key);
std::cout<<"edb2("<<Pub_key.x<<Pub_key.y<<Pub_key.z<<"\n";
exit(1);
}
//print"inforloop",i,";
}


}

//noreturn--print"afterreturn\n"
}




/*=begin
ECDSAsignatureenerationandverification
Tosignameddahem,anentryAwithdomainparametersD=(q,FR,a,b,G,n,h)
andassociatedkeypair(d,Q)doesthefollowing

1.Selectarandomorpseudorandomintegerk,1<=k<=n-1
2.ComputekG=(x1,y1)andr=x1modn.Ifr=0thengotostep1.
3.Computek^{-1}modn.
4.Computee=sha1(m)
5.Computes=k^{-1}(e+dr)modn.Ifs=0thengotostep1.
6.A'ssignatureforthemessagemis(r,s).
=end
*/
po rs;
po ecdsa(BigInt k,BigInt e,BigInt d){
BigInt r,s;
ten U;

std::cout << "in_ecdsa\n";

init_curve(256);
mktbl3(CRV.G);
if(k<0){
std::cout<<"kisobsenseinecdsa\n";
exit(1);
}

elp3(k);
//U=elp(k,CRV.G);
//#print"Ex=",e_x,"\n";
r=P.x%CRV.n;
std::cout<<r,"\n";
k=inv(k,CRV.n);
//#e=sha(argc,argv);
s=(k*(e+d*r))%CRV.n;
std::cout<<s<<endl;
//#print"k=",k,"\n"
//#print"d=",d,"\n"
//#print"e=",e,"\n"
rs.x=s;
rs.y=r;

return rs;

}

/*
=begin
ECDSAsignaturevelification
1.Verifythatrandsareintegersintheinterval[1,n-1]
2.Computee=sha1(m)
3.Computew=s^{-1}modn.
4.Computeu1=ewmodnandu2=rwmodn.
5.ComputeX=u1G+u2Q.IfX=O,thenrejectthesignature.Otherwise,compute
v=x1modnwhereX=(x1,y1)
6.Acceptthesignatureifandonlyifv=r.
=end
*/
void vr_ecdsa(BigInt s,BigInt r,BigInt e){
BigInt w,u1,u2,gx,gy,gz,qx,qy,qz,xx,yy,v,zz;
FILE *fp;
unsigned char key[32*3];
BigInt I,px,py,pz;
int i;
ten T,G1,G2,R;

std::cout<<"in_vr_ecdsa\n";
fp=fopen("eccpub.key","rb";
fread(key,1,sizeof(key),fp);
fclose(fp);

I=0;px=py=pz=0;
for(i=0;i<32;i++){
I=key[i];
px^=I<<(i*8);
}
for(i=0;i<32;i++){
I=key[i+32];
py^=I<<(i*8);
}
for(i=0;i<32;i++){
I=key[i+64];
pz^=I<<(i*8);
}
T.x=px;
T.y=py;
T.z=pz;

//#e=sha(argc,argv);
w=inv(s,CRV.n);
u1=e*w%CRV.n;
//#std::cout<<"u1="<<u1<<endl;
u2=r*w%CRV.n;

std::cout<<"Gen_key\n";
mktbl3(CRV.G);
elp3(u1);//#G=
	//R=elp(u1,CRV.G);
G1=P;

mktbl3(T);
elp3(u2);//#Q=
	//R=elp(u2,T);
G2=P;

if(G1.x==G2.x&&G1.y==G2.y){
std::cout<<"equalpoint\n";
exit(1);
}


if(G1.x!=G2.x){
jadd(G1,G2);//#X=
xx=P.x;
yy=P.y;
zz=P.z;
}
v=xx%CRV.n;
std::cout<<"ris",r,"\n";
std::cout<<"vis",v,"\n";

if(v==r)
std::cout<<"That'strue!\n";

if(v!=r)
std::cout<<"baka\n";

}




void genkey(unsigned char str[256], unsigned char t[256]){
FILE* fp,*fq;
unsigned char *filename;
unsigned char buf[256];
int i;

printf("genkey\n";
/*
if(fp=fppen("key.bin","rb"!=NULL){
std::cout<<"既に鍵ファイルが存在します。新しい鍵ファイル名を入力してください。\n";
std::cin>>filename;
}
*/
//std::cout<<str<<endl;
std::cout<<t<<endl;



hasha(t);
fp=fopen("seed.key","wb";
fwrite(c1.dd,1,16,fp);
fwrite(c2.dd,1,16,fp);
hasha(str);
fwrite(c1.dd,1,16,fp);
fwrite(c2.dd,1,16,fp);
std::cout<<"共有鍵seed.keyが生成されました。"<<endl;
fclose(fp);

}


void ecdh(){
BigInt ax,ay,az,b,cx,cy,cz,bf[32],I,key;
FILE *fp,*fq;
unsigned char buf[32],buff[4],str[32*3],tt[256];
int i,j,nn,II[32*3];
ten X;

fp=fopen("key.bin","rb";
fread(buf,1,32,fp);
fclose(fp);
init_curve(256);
mktbl3(CRV.G);
if(fp==NULL){
std::cout<<"鍵ファイルが見つかりません。"<<endl;
exit(1);
}
I=key=0;
for(i=0;i<32;i++){
I=buf[i];
key^=I<<(i*8);
}
elp3(key);
X=P;


for(i=0;i<32;i++){
bf[i]=X.x%256;
X.x=(X.x>>8);
conv(II[i],bf[i]);
}
for(i=0;i<32;i++){
bf[i]=X.y%256;
X.y=(X.y>>8);
conv(II[i+32],bf[i]);
}
for(i=0;i<32;i++){
bf[i]=X.z%256;
X.z=(X.z>>8);
conv(II[i+64],bf[i]);
}
for(i=0;i<32*3;i++){
str[i]=II[i];
//std::cout<<to_BigInt(str[i]);
}
std::cout<<"認証パスワードを設定します\n";
freopen("con","r",stdin);
scanf("%s",&tt);
std::cout<<"in_"<<tt<<endl;
hasha(tt);

//exit(1);

genkey(str,tt);


//lk(tt);
fclose(fp);

}

void keygen(BigInt r){
//BigIntr;
FILE *fp;
unsigned char c[32*3];
int i;

fp=fopen("eccpub.key","wb";
init_curve(256);
mktbl3(CRV.G);
//std::cin>>r;
elp3(r);
std::cout<<"y="<<Pub_key.y<<endl;

for(i=0;i<32;i++){
c[i]=Pub_key.x%256;
Pub_key.x=Pub_key.x>>8;
}
for(i=0;i<32;i++){
c[i+32]=Pub_key.y%256;
Pub_key.y=Pub_key.y>>8;
}
for(i=0;i<32;i++){
c[i+64]=Pub_key.z%256;
Pub_key.z=Pub_key.z>>8;
}

fwrite(c,1,sizeof(c),fp);
fclose(fp);
for(i=0;i<32*3;i++)
c[i]=0;
for(i=0;i<32;i++){
c[i]=r%256;
r=(r>>8);
}
fp=fopen("eccsec.key","wb";
fwrite(c,1,32,fp);
fclose(fp);

exit(1);
}


void enc(char *argv[],int nn){
  FILE *fp,*fq,*fr;
  BigInt salt,buf[32],aa,II;
  int i,read_size,ii,c,k,a,j,count=0,cnt=0;
  unsigned int I[32];
  unsigned char buff[SIZE],str,*e,m[32],ai[32],key[32*3];
  unsigned char *to;
  ten X;

  
  init_curve(nn);
  salt=sha2(2,argv);
  //std::cin>>salt;
  
  if(sizeof(argv)==0)
    std::cout << "usage: inputfile outfile\n";

  fp=fopen(argv[1],"rb";
  fq=fopen(argv[2],"wb";
  
  //mktbl3(CRV.G);
  //elp3(salt);
  Pub_key=elp(salt,CRV.G);
  std::cout << "y=" << Pub_key.y << endl;
  
  for(i=0;i<32;i++){
    key[i]=Pub_key.x%256;
    Pub_key.x= Pub_key.x>>8;
  }
  for(i=0;i<32;i++){
    key[i+32]=Pub_key.y%256;
    Pub_key.y= Pub_key.y>>8;
  }
  for(i=0;i<32;i++){
    key[i+64]=Pub_key.z%256;
    Pub_key.z= Pub_key.z>>8;
  }
  fwrite(key,1,sizeof(key),fq);
  
  
  fr=fopen("eccpub.key","rb";
  fread(key,1,sizeof(key),fr);
  fclose(fr);
  
  
  Pub_key.x=0;
  Pub_key.y=0;
  Pub_key.z=0;
  for(i=0;i<32;i++){
    II=key[i];
    Pub_key.x^= II<<(i*8);
  }
  for(i=0;i<32;i++){
    II=key[i+32];
    Pub_key.y^= II<<(i*8);
  }

  std::cout<<"py="<<Pub_key.y<<endl;
  for(i=0;i<32;i++){
    II=key[i+64];
    Pub_key.z^= II<<(i*8);
  }
  
  mktbl3(Pub_key);
  elp3(salt);
  //  X=elp(salt,Pub_key);
  
  X.x=Pub_key.x;
  X.y=Pub_key.y;
  X.z=Pub_key.z;
  
  //X=elp(salt,Pub_key);
  std::cout << "y=" << X.y << endl;
  
  //  memset(I,0,sizeof(I));
  //memset(buf,0,sizeof(buf));
  //memset(ai,0,sizeof(ai));


  
  
  while((read_size=fread(buff,1,32,fp))>0){
    for(i=0;i<32;i++){
      I[i]=0;buf[i]=0;ai[i]=0;
    }
    for(i=0;i<read_size;i++)
      ai[i]=buff[i];
    
    salt=0;
    for(i=0;i<read_size;i++){
      II=to_BigInt(ai[i]);
      salt^= II<<(i*8);
    }
    //
    
    std::cout << salt << endl;    
    jadd(X,CRV.G); //一つづつ足す
    salt^=P.y;

    //    exit(1);

    
    X.x=P.x;
    X.y=P.y;
    X.z=P.z;
    
    
    for(i=0;i<32;i++){
      buf[i]=salt%256;
      conv(I[i],buf[i]);
      salt=(salt>>8);
    }
    
    for(i=0;i<32;i++){
      m[i]=(unsigned char)I[i];
            if(m[i]!=I[i]){
	std::cout << "baka in enc\n";
	exit(1);
      }
    }
    
    fwrite(m,1,read_size,fq);
    //        exit(1);
  }
  
  fclose(fp);
  fclose(fq);
  
}



void dec(char *argv[],int nn){
  BigInt salt,buf[32],a,II,r;
  ten R;
  unsigned char buff[32],ai[32],key2[32],key[32*3];
  FILE *fp,*fq,*fr;
  int read_size,i,j,count=0,cnt=0;
  unsigned int I[32];
  unsigned char m[32];

  
  
  printf("indec\n";
  init_curve(nn);
  fr=fopen("eccsec.key","rb";
  fread(key2,1,32,fr);
  fclose(fr);
  
  r=0;
  for(i=0;i<32;i++){
    II=key2[i];
    r^=(II<<(8*i));
  }
  //std::cin>>Pub_key.x;
  //std::cin>>Pub_key.y;
  //std::cin>>Pub_key.z;
  
  
  R.x=0;
  R.y=0;
  R.z=0;
  fp=fopen(argv[2],"wb";
  fq=fopen(argv[1],"rb";
  fread(key,1,32*3,fq);
  for(i=0;i<32;i++){
    II=key[i];
    R.x^=II<<(i*8);
  }
  for(i=0;i<32;i++){
    II=key[i+32];
    R.y^=II<<(i*8);
  }
  for(i=0;i<32;i++){
    II=key[i+64];
    R.z^=II<<(i*8);
  }
 
  mktbl3(R);
  elp3(r);
  //    Pub_key=elp(r,R);

 //std::cout<<"dcPubkey.x="<<Pub_key.x<<"\n";
  //  std::cout<<"dcPubkey_y="<<Pub_key.y<<"\n";
 //std::cout<<"dcPubkey.z="<<Pub_key.z<<"\n";
 //salt=0;


  while(read_size=fread(buff,1,32,fq)){
    for(i=0;i<32;i++){
      buf[i]=0;m[i]=0;
    }
    //std::cout<<"r="<<read_size<<endl;

    salt=0;
    for(i=0;i<read_size;i++){
      //std::cout<<to_BigInt(buff[i])<<endl;
      II=to_BigInt(buff[i]);
      salt^= II<<(i*8);
    }
    //exit(1);
    //salt^=to_BigInt(buff[read_size-1]);

    //padding
    a=salt;
    while(a>0){
      j++;
      a=(a>>8);
    }


    jadd(Pub_key,CRV.G);
    salt^=P.y; //%(256*read_size));
    std::cout << salt << endl;

    
    
    //    exit(1);
    a=salt;
    Pub_key.x=P.x;
    Pub_key.y=P.y;
    Pub_key.z=P.z;
    
    for(i=0;i<32;i++)
      I[i]=0;
    for(i=0;i<read_size;i++){
      m[i]=salt%256;
      //conv(I[i],buf[i]);
      salt=(salt>>8);
    }
   
    //    exit(1);    
    
    fwrite(m,1,read_size,fp);
   
    //printf("dec=%d\n",read_size);
  }
 
  fclose(fp);
  fclose(fq);
 
}


void nizk(){
BigInt r,c,x,b;

mktbl3(CRV.G);
elp3(r);
//elp(r,CRV.G);
std::cout<<"inputchallenge\n";
std::cin>>c;
b=c-r*x;

}

/*
defotp(x,nn)

init_curve(nn)

r=[0xf874f8444567019dae5d0686dd04f2615204d38875190df1f54af6,0xe814985c80ee06915a0ab4580dd00fe97b37dc2e84110ff5fd6f7a,0xc854f064ce120797a3b76389d309f9711c5cbc51a7140cfbfd2efb,0xe814d03c85dc089feaf00ce85d805f4415c30c467201a0cfcf2f8ef,0xf834d8648cdd0f925ac0fcf84d80bfd190364c59c6e1d06fafc9fed,0xc844a82c9d580f9eca708ef8ada0bfe19547195809f190af9f3d863,0xf04ce82c58030f97da0d1188fdd0cf421035ec231911b03f5f2da40,0xd024f8442d2c009ba497998cd301f1713b1ea021ad1808fcf226e4,0xc87c800463fa0b965aa983c8bd90efc712331a2dc4d1506fcf29a5b,0x9864801c5d0706973a8de1885dd08f671635af27299130af1f26348,0xc82ca0442d2e039ada09b9580db03fb311b35ab2c0d1f0afff8db2e,0x9024f05431370f96dab2caf81d504fe415346894a511b09f1f70d22,0xd01ca824540f08989aad31c80d607f497b2396401c1509f7f4d2af,0x901cb04c4fc5059ccafe75980d20cf961137eb957a91a0ef5f824f5,0xe02cd00c54c6059e7ab4e3885d203f3213301a55590180cfafa2c57,0xa07cb0745d040591ca4dd1c89d109f1390461fa641a100df8f0ece3,0xc034b05c4863039f5a3570b8bdb03ff614b75b24f04110bf1f11075,0x9844f00488df0b96a807ce84d005fc39232ac5dda11b01f2fb3198,0xe82c905c5a0204978a2dd1388d600f5495418fe17c2150cf8f32e3b,0x903cf8442c270497aa694988dda00f5393b20d0db1e1e04f2fe7b0c,0xe05c903c81df0e9e4a10fcb88d208f5412c24bf43cc1102fef7aae2,0x800cb0045a0605909aad11980df0efc513b219a2d291e0cfef0ff6a,0xf034e83caf5d05912af6cf189db05f9313b33958c7e1f09f0f7f425,0xd02c887cc4130d9c7acb16e85db00f1614334fec5b41101f1f74d85,0x9004a86457c20e9aca44e3a8cd90ef0293b3eac8192190bf8f2da66,0xe864d8143b310d96fa629a385d304fc692b0ed578191402f4f89fb0,0x904c800c570a0896bacd81d86db04f4194369c995fb1a04fdfbfb03,0xd85cf0048ade0898fabb51385d904fa395424dc9ac51503f0fec3a0,0xe86ca8544ecd079faace75781da05f2291427be39931b0ffff0d841,0xf87c986c21210892ead9b9482d80df6494376b091c01e02fcfac7aa,0xd83c8014313b0b901aa20a68ed90df1115c3fd919df1b0df4fc193f,0x883c805ca45c04901a969f384dd01ff690c22b845cb1f0df4f8a9ef,0x8864906c48ce02994a3e55f83d807fa793b01957a5e1900f0fefa8a,0xe0149834446706988a1590b89d30dfb710c3cd7adf91108fffc9c17,0xb02cf0744ec40c9bca7e45280de09f26742aae5fa51002fff82aff,0xa864e07c66f703946aa9b328bd904f871033184602e130ef7fefbe5,0xb824c87494f305966abb42680dd0ef0695c6ce234d1506fdfad977,0x8044f02c5c000c9b4a0d41884de07f495416ec7f901301f6f06f4c,0xd87c887ccb8904974a6981b87d009fa313b34cb4e6a160efaf97097,0x885cb8642d210197ba5939086d804fb69035cae252d160bf3f1f067,0xc074880c80d80b99dab0ec48ed107f31437cad8da1701f0f78483,0x986cb82c4d6c0c968a551078fd20df6614b33b44db01302f5f64ba3,0xe87cb0748bd70098da1b01883db0ff571230feed8321e0cf0f1767a,0xd82cd81c4fc80c92ba8e65788d604ff492b0cdcec141e0df5f4cec2,0x9824987c35350897fa523a287d008f3790356905e601502f9f3b3df,0xf064b054252907975ae999582d907f3690b70b286761007fbf0f920,0xa004c06c81dc029dda10fcf8ed905f31532c9eacd71b0ef3f75cc8,0xa06cd84c310c0d9c9a5dc248bd40af3292b569b47bf1802f1fc49a0,0xe834a0245bc6079f9a44d3d83dd09f1316c1fd645691f04f2fe14ba,0xd86cf83c2f260d9cbac949681d705f1712c42f861501701f8f269dd];
c=[0x8014b87450cd0a96fac4b3389d504f6297b1dd23d51101fcf38a80,0x9044a0145c0b099d8a0d7128ad708f02963039499f31a06f6f7fd08,0xa054e86480e00f9e4a4ad478cd909f7396b04ef8e7e160dfcf9fe2d,0xe01c882487da0b948aebe1c87d30bf7390c63d9ea13150dfbf5cfcb,0xc034882c58c90692fa9493085d308fc311316d34fc11600ffffaae1,0x8024d07c3a360c99ac2ca08ed60bf41e1c49f292f01807fdf3f80a,0xa804d02c406a07982a85d0281d401fa514b6cd7a8d61f00f2f555cc,0xb864b07ca9560495a56af08dd20af3510b36f3887d1e08f5fc4af0,0xd064c06c86e70b959abad4481db0af4795c6fb5ed041709f5f69ab2,0x907c90148ce60e95eaea24b80d80ef731631ac925011b0af8f3d627,0xb854c86c390c01904a8d12989d809fa795b4ec18a98140df8ffda6e,0x8054d0244cc50b919abe7558bde05f4394c36ed5da41d07fff8acc7,0xe05c984c446307954a4500c82dd0cf4314b218bd34a1109f8f14bc6,0xa824b03480e20497ca0af418cd704f079436793e3b2140cfef8fc45,0xa004f0448bd90896a60dc785d90cf293b6cd881771b02f6fc47fc,0xa034e8145a050e9a3a3d81a8ed108f649241fc4268c1c0cf4f26771,0xf82c90043935029f2ab21a282da01f2513b15c599641405f3f39ee2,0xa874e81c2528009f9a69e928ad909f5110b31c24c1d1c0ff4f5dba8,0x807c884c80d401935a506ca8fd10ff1792b06a9ab0d1707f1fad1d4,0x883cb83c6ef400968ac9e308bd80ff2914169394e21504fef3a413,0x987cb86c89de069dea5bc158bda00fd590b498f55a91e0df1f721f9,0xd85cc04c340d08999a3d22b81d309f7197b69ec65521a05f0f968d0,0x885cc8744b6900994ae5a0382d80ff2695b45c36717150cf0fce3ea,0xa01cf874c51b0496ba0b26486d800ff690c7db586671a0cf2feb795,0xe84cb00c50010195dabdd1f84d60bfe293468b72de1a05f3fc8086,0xc814a07c81ea049eafa34e8ed50cf4314c4b8fe5101309f7f6cfca,0xe804d02c52020c9f1a9d61882d50af5416316c32d811d0ef8f7637c,0xa07cf07489d708902a50ec685d005fc394b6dfca8001b01f0f0d9d9,0xf034a80caa5f059e1a16ff988d900f069331eb2d1a71807fdf93599,0xc024c044590204942afdf1188d400f592358b6a9d5190df4fa5aca,0xb83ce87c59cf0a9d1ad4e328ad40df341545edb5d9f180bfcf92c52,0xf044c014370f019d9add52580d505f9112361fb44c11203f0fcaeea,0xa014900482e4079afafab4288d408fd295450b52605120df9fdd92d,0xc01cb06c3b340498baf28ac8cd400fa614c66816961e0ef3ff8ee9,0x8844a87ca45d06993a66dff84d40dff515c2a954c77150efbfd872f,0xa834d04c4e6807924a15c0a8adc08fb51240b9986711f05f1f64df6,0xe064f07438390896ea82aa28fd108f41032eb4c3be1909fbf24080,0x8024f82c5703089fa7df118ed702fa792b6f84dca21500fefa3b9c,0x981cf80c88d00e92fa805c884d004fd417c68fe1bc21e00f9fc2338,0x9844e8643c3906988ad24a18fd600f1116c69f0808b1a09f6f4b6cf,0xf814c82447cd0497ca1ed598ed701f7195b28b34de160cfdf4898a,0xe864e86c85d80e917a40fc68ada05fe69230be7e8961805f1fadcb3,0x884cd83cc61907945abb1688fd001fa39345ef190e81c04fdf7a61d,0xf854a01c98f703986acbf2386d305f710361c67b59140ef5f3fe83,0x8034f074af5c06958a66ffb80d109ff596b13cc19c71009f6fd2536,0xe07c8874320f0f967aeda298bd908fe293471f027a71409fcf822ea,0xc824802c5c090c9aaaad91680d90efc596b39a5cda130af2fa858f,0xa07ca82c98550291cac09e58edd07f5591c2b9f307f1a01f9f70b5b,0xc024904cc413079ea4b3658adf0ff7712b03d2bba31609f5fcd069,0x8014c02450080b9ecacd11d84d509fb19042ead38931a09f6f6dd49]
a.x=[50]
a.y=[50]
a.z=[50]
b=[50]

mktbl3(CRV.G.x,CRV.G.y,CRV.G.z)
//ellip(CRV_n)
//exit()

flag=0
elp3(x)
y.x=Pub_key.x
y.y=Pub_key.y
y.z=Pub_key.z
d.x=[50]
d.y=[50]
d.z=[50]
e.x=[50]
e.y=[50]
e.z=[50]

foriin0..49
elp3(r[i])
a.x[i]=Pub_key.x
a.y[i]=Pub_key.y
a.z[i]=Pub_key.z
printr[i],"\n"
end
foriin0..49
b[i]=(r[i]-c[i]*x)%CRV.n
print"b=",b[i],"\n"
end
foriin0..49
elp3(b[i])
d.x[i]=Pub_key.x
d.y[i]=Pub_key.y
d.z[i]=Pub_key.z
print"dx=",d.x[i],"\n"
end
foriin0..49
elp3(c[i]*x)
e.x[i]=Pub_key.x
e.y[i]=Pub_key.y
e.z[i]=Pub_key.z
print"c=",c[i],"\n"
end
//exit()
foriin0..49
jadd(d.x[i],e.x[i],d.y[i],e.y[i],d.z[i],e.z[i],CRV.p)
if(P.x!=a.x[i]||P.y!=a.y[i]||P.z!=a.z[i])
	//print"i=",i,"\n"
flag=1
end
end
if(flag==0)
print"That'sTrue!\n"
end
if(flag==1)
print"baka\n"
end

end
*/



void logcom(int nn,int argc,char *argv[]){
int j=0;
BigInt plain[21],ai,nha,r;
ten v,c,gr,vm;
combo e;


init_curve(nn);
mktbl3(CRV.G);
//elp3(CRV_n)
//printeccp192,"\n"


//printsecp128r1_p,"\n"


//schlorbai
plain[0]="30166869646807636562727106419";
plain[1]="10045117565996920939000919144";
plain[2]="30153181069665353679546770802";
plain[3]="10033396893489366934389337632";
plain[4]="22631414519632726019188813428";
plain[5]="10044280489496830406925033588";
plain[6]="32308695848121561557187447072";
plain[7]="21179691622725275949743743092";
plain[8]="32308695848121561556958080800";
plain[9]="30765204363694166514334572576";
plain[10]="26119354342939208172857421088";
plain[11]="30059276595547511335976247399";
plain[12]="34493224637425338651624109358";
plain[13]="22631636489395346365953810503";
plain[14]="34473881935204201160487432814";
plain[15]="32629405756452437358033266789";
plain[16]="10024939110908884670107837728";
plain[17]="36265758736633729355313211168";
plain[18]="30151120555452877393537363824";
plain[19]="33546635831558563763501754217";
plain[20]="34161127499042836141910073459";


//plaintext


//encryption
ai=plain[1];
//std::cout<<"r1="<<ai<<"\n";
elp3(ai);
v.x=Pub_key.x;
v.y=Pub_key.y;
v.z=Pub_key.z;
//printv_x,",v_y,"\n"

e=hash2(argc,argv);
nha^=e.e1.dd[0];
nha=(nha<<64);
nha^=e.e1.dd[1];
nha=(nha<<64);
nha^=e.e2.dd[0];
nha=(nha<<64);
nha^=e.e2.dd[1];

std::cout<<"mha="<<nha<<"\n";
mktbl3(v);
elp3(nha);
c.x=Pub_key.x;
c.y=Pub_key.y;
c.z=Pub_key.z;
//printc_x,",c_y,"\n"
std::cin>>r;
std::cout<<r<<endl;
mktbl3(CRV.G);
elp3(r);
gr.x=Pub_key.x;
gr.y=Pub_key.y;
gr.z=Pub_key.z;
jadd(gr,c);
Gen_key.x=P.x;
Gen_key.y=P.y;
Gen_key.z=P.z;
if((Gen_key.y*Gen_key.y)%CRV.p!=((Gen_key.x*Gen_key.x*Gen_key.x)+CRV.a*Gen_key.x*Gen_key.z*Gen_key.z*Gen_key.z*Gen_key.z+CRV.b*Gen_key.z*Gen_key.z*Gen_key.z*Gen_key.z*Gen_key.z*Gen_key.z)%CRV.p){
std::cout<<"error!!\n";
exit(1);
}

if((Gen_key.y*Gen_key.y)%CRV.p==((Gen_key.x*Gen_key.x*Gen_key.x)+CRV.a*Gen_key.x*Gen_key.z*Gen_key.z*Gen_key.z*Gen_key.z+CRV.b*Gen_key.z*Gen_key.z*Gen_key.z*Gen_key.z*Gen_key.z*Gen_key.z)%CRV.p){
std::cout<<argv[1]<<"'sLogCommitmentis"<<"\n";
std::cout<<"x="<<Gen_key.x<<"\n";
std::cout<<"y="<<Gen_key.y<<"\n";
std::cout<<"z="<<Gen_key.z<<endl;
}

}


//
//otp(133,2244)

int ecc(int argc,char *argv[]){
unsigned char *str,m[32],s[32],ss[64];
BigInt x,y,z,salt;
int i,n,mm[32];
FILE *fp;
//std::cout<<"inputecc256,2562,2563,2564,2565"<<endl;
//std::cin>>i;
n=256;
init_curve(n);
//logcom(256,argc,argv);
//exit(1);

fp=fopen("key.bin","rb";
if(fp==NULL){
printf("鍵ファイルがありません。\n";
exit(1);
}
fread(m,1,32,fp);
salt=0;
for(i=0;i<32;i++)
salt=(salt<<8)^m[i];

fclose(fp);
if(!strcmp(argv[1],"x"&&argv[2]==NULL){
std::cout << "ecdh Version 0.01α　\n 実行ナンバーを指定してください。" << endl;
std::cout << "０：自分の公開鍵を生成する。" << endl;
std::cout << "１：鍵ファイルにDSA2署名を生成する" << endl;
std::cout << "２：受信した鍵の署名を検証する" << endl;
std::cout << "３：相手の公開鍵を入力して共有鍵を生成する" << endl;
exit(1);
}
if(salt < 1){
std::cout << "鍵が不正です。" << endl;
exit(1);
}

if(!strcmp(argv[2],"0"){
keygen(salt);
 exit(0);
}
if(!strcmp(argv[2],"3"){
  ecdh();
 exit(0);
}
if(!strcmp(argv[2],"1"){
dsa2(argc,argv);
	exit(0);
}
if(!strcmp(argv[2],"2"){
dsa2(argc,argv);
	exit(0);
}
 else if(strcmp(argv[2],"0"&&strcmp(argv[2],"1"&&strcmp(argv[2],"2"&&strcmp(argv[2],"3"){
std::cout<<"存在しないモードです。"<<endl;
exit(1);
}

//ecdh("12","97",n);

return 0;
}



int main(int argc,char *argv[]){
  BigInt z,r,d,I,salt;
  int i;
  char m[1];
  FILE *fp;
  unsigned char key[32];
  po sig;
  char file[32];
  ten T;


  std::cout << "if argv1=k then key pair generate\n";
 if(strcmp(argv[1],"k"==0){
   seed();
   argv[1]="-s";
   argv[2]=password;
   salt=sha2(3,argv);
   keygen(salt);
 }

 std::cout<<"input mode e or d or s\n";
 std::cin >> m;
 if(strcmp(m,"e"==0)
   enc(argv,256);


 if(strcmp(m,"h"==0){
   std::cout<<"usage:e file encryption; d file decryption; s generate signature; \n";
   return 0;
 }
 if(strcmp(m,"d"==0)
   dec(argv,256);
 
 if(strcmp(m,"s"==0){
   I=0;d=0;
   fp=fopen("eccsec.key","rb");
   fread(key,1,32,fp);
   fclose(fp);
   for(i=0;i<32;i++){
     I=key[i];
     d^=I<<(i*8);
   }
   std::cin>>r;
   z=sha2(argc,argv);
   sig=ecdsa(r,z,d);
   vr_ecdsa(sig.x,sig.y,z);
 }
 
return 0;
}
